/// ------------------------------------------------------------------
/// Copyright (c) 1996, 2004 Vincent Risi in Association 
///                          with Barone Budge and Dominick 
/// All rights reserved. 
/// This program and the accompanying materials are made available 
/// under the terms of the Common Public License v1.0 
/// which accompanies this distribution and is available at 
/// http://www.eclipse.org/legal/cpl-v10.html 
/// Contributors:
///    Vincent Risi
/// ------------------------------------------------------------------
/// System : JPortal
/// $Date: 2004/10/18 13:45:47 $
/// $Revision: 411.1 $ // YMM.Revision
/// ------------------------------------------------------------------

package bbd.jportal;

import java.io.*;
import java.util.Properties;
import java.util.Vector;
import static bbd.jportal.Writer.*;

public class PyBind11PyCode extends Generator
{
  public static String description()
  {
    return "Generate PyBind11 Code for Idl2 Client Python";
  }
  public static String documentation()
  {
    return "Generate PyBind11 Code for Idl2 Client Python";
  }
  private static Properties properties;
  static boolean useEnum = false;
  private static PrintWriter outLog;

  public static void generate(Database database, String output, PrintWriter inOutLog)
  {
    outLog = inOutLog;
    for (int i=0; i<database.tables.size(); i++)
    {
      Table table = database.tables.elementAt(i);
      generateStructs(database, table, output, outLog);
    }
  }
  /**
   * Build of standard and user defined procedures
   */
  static void generateStructs(Database database, Table table, String output, PrintWriter outLog)
  {
    try
    {
      outLog.println("Code: " + output + table.useName() + "Bind11.py");
      OutputStream outFile = new FileOutputStream(output + table.useName() + "Bind11.py");
      try
      {
        writer = new PrintWriter(outFile);
        indent_size = 4;
        try
        {
          writeln("# This code was generated by PyBind11PyCode, do not modify it, modify it at source and regenerate it.");
          writeln("# see " + table.useName() + " source file");
          writeln();
          writeln("#import dbapi_util");
          writeln("#from dbapi_annotate import *");
          writeln();
          generateEnums(database);
          generateEnums(table);
          if (table.hasStdProcs)
            generateStdOutputRec(table);
          generateUserOutputRecs(table);
          //generateCode(table);
          writer.flush();
        }
        finally
        {
          writer.flush();
        }
      }
      finally
      {
        outFile.close();
      }
    }
    catch (IOException e1)
    {
      outLog.println("Generate Procs IO Error");
    }
  }
  static String _commanull(Field field)
  {
    if (field.isNull) return(", null=True");    
    return "";
  }
  static String _null(Field field)
  {
    if (field.isNull) return("null=True");    
    return "";
  }
  static void generateAnnotates(Vector allFields)
  {
    for (int i = 0; i < allFields.size(); i++)
    {
      Field field = (Field) allFields.elementAt(i);
      write(1, format("%s: ",field.useName()));
      switch (field.type)
      {
      case Field.ANSICHAR:
        writeln(format("Char(%d%s)", field.length+1, _commanull(field)));
        break;
      case Field.AUTOTIMESTAMP:
        writeln(format("TimeStamp(%s)", _null(field)));
        break;
      case Field.BIGIDENTITY:
      case Field.BIGSEQUENCE:
      case Field.LONG:
        writeln(format("LongInt(%d%s)", field.length, _commanull(field)));
        break;
      case Field.BIGXML:
        writeln(format("XMLTYPE(%d%s)", field.length+1, _commanull(field)));
        break;
      case Field.BLOB:
        writeln(format("Blob(%d%s)", field.length+1, _commanull(field)));
        break;
      case Field.BOOLEAN:
        writeln(format("Boolean(%d%s)", field.length, _commanull(field)));
        break;
      case Field.BYTE:
        writeln(format("TinyInt(%d%s)", field.length, _commanull(field)));
        break;
      case Field.CHAR:
        writeln(format("Char(%d%s)", field.length+1, _commanull(field)));
        break;
      case Field.DATE:
        writeln(format("Date(%s)", _null(field)));
        break;
      case Field.DATETIME:
        writeln(format("DateTime(%s)", _null(field)));
        break;
      case Field.DOUBLE:
      case Field.FLOAT:
        writeln(format("Float(%d, %d%s)", field.precision, field.scale, _commanull(field)));
        break;
      case Field.DYNAMIC:
        writeln(format("Unhandled('Dynamic', %d%s)", field.length, _commanull(field)));
        break;
      case Field.IDENTITY:
      case Field.INT:
      case Field.SEQUENCE:
        writeln(format("Int(%s%s)", field.length, _commanull(field)));
        break;
      case Field.IMAGE:
        writeln(format("Image(%s%s)", field.length+1, _commanull(field)));
        break;
      case Field.MONEY:
        writeln(format("Char(%s%s)", field.length+1, _commanull(field)));
        break;
      case Field.SHORT:
        writeln(format("SmallInt(%s%s)", field.length, _commanull(field)));
        break;
      case Field.STATUS:
        writeln(format("Status(%s%s)", field.length, _commanull(field)));
        break;
      case Field.TIME:
        writeln(format("Time(%s)", _null(field)));
        break;
      case Field.TIMESTAMP:
        writeln(format("TimeStamp(%s)", _null(field)));
        break;
      case Field.TLOB:
        writeln(format("Clob(%s%s)", field.length+1, _commanull(field)));
        break;
      case Field.UID:
        writeln(format("Unhandled('UID', %s%s)", field.length, _commanull(field)));
        break;
      case Field.USERSTAMP:
        writeln(format("UserStamp(%s%s)", field.length+1, _commanull(field)));
        break;
      case Field.UTF8:
        writeln(format("Unhandled('UTF8', %s%s)", field.length+1, _commanull(field)));
        break;
      case Field.WANSICHAR:
        writeln(format("Unhandled('WANSICHAR', %s%s)", field.length+1, _commanull(field)));
        break;
      case Field.WCHAR:
        writeln(format("Unhandled('WCHAR', %s%s)", field.length+1, _commanull(field)));
        break;
      case Field.XML:
        writeln(format("XMLTYPE(%s%s)", field.length+1, _commanull(field)));
        break;
      }
    }
  }
  static void generateDataFields(Vector allFields, String superName, String tableName)
  {
    String recName = superName.length() > 0 ? superName : tableName;
    writeln(1, "def __init__(self):");
    for (int i = 0; i < allFields.size(); i++)
    {
      Field field = (Field)allFields.elementAt(i);
      if (isNull(field) == true)
        writeln(2, "self." + field.useName() + " = None");
      else
        writeln(2, "self." + field.useName() + " = ''");
    }
  }
  static void generateStdOutputRec(Table table)
  {
    writeln("class D" + table.useName() + "():");
    generateAnnotates(table.fields);
    writeln(1, "def _make(self): return D" + table.useName() + "()");
    generateDataFields(table.fields, "", table.useName());
    writeln();
  }
  static void generateUserOutputRecs(Table table)
  {
    for (int i = 0; i < table.procs.size(); i++)
    {
      Proc proc = table.procs.elementAt(i);
      if (proc.isData || proc.isStd || proc.hasNoData())
        continue;
      if (proc.isStdExtended())
        continue;
      String superName = table.useName() + proc.upperFirst();
      Vector<Field> procFields = new Vector<Field>();
      writeln("class D" + superName + "():");
      for (int j = 0; j < proc.inputs.size(); j++)
      {
        Field field = proc.inputs.elementAt(j);
        procFields.addElement(field);
      }
      for (int j = 0; j < proc.outputs.size(); j++)
      {
        Field field = proc.outputs.elementAt(j);
        if (proc.hasInput(field.name) == true)
          continue;
        procFields.addElement(field);
      }
      for (int j = 0; j < proc.dynamics.size(); j++)
      {
        Field f = new Field();
        f.name = proc.dynamics.elementAt(j);
        f.type = Field.CHAR;
        procFields.addElement(f);
      }
      generateAnnotates(procFields);
      writeln(1, "def _make(self): return D" + superName + "()");
      generateDataFields(procFields, superName, table.useName());
      writeln();
    }
  }
  static void generateEnums(Table table)
  {
    for (int i = 0; i < table.fields.size(); i++)
    {
      Field field = table.fields.elementAt(i);
      generateEnums(table.useName() + field.useName(), field);
    }
  }
  static void generateEnums(Database database)
  {
    for (int i = 0; i < database.declares.size(); i++)
    {
      Field field = database.declares.elementAt(i);
      generateEnums(database.name + field.useName(), field);
    }
  }
  static void generateEnums(String baseName, Field field)
  {
    if (field.enums.size() > 0)
    {
      if (useEnum == true)
        generateEnumsAsEnum(baseName, field);
      else
        generateEnumsAsDict(baseName, field);
    }
    else if (field.valueList.size() > 0)
    {
      writeln("class " + baseName + ":");
      for (int j = 0; j < field.valueList.size(); j++)
      {
        String entry = field.valueList.elementAt(j);
        writeln(1, entry + " = '" + entry + "'");
      }
      writeln();
    }
  }
  static boolean enumImport = false;
  static void generateEnumsAsEnum(String baseName, Field field)
  {
    if (enumImport == false)
    {
      writeln("from enum import Enum");
      writeln();
      enumImport = true;
    }
    writeln(format("class %s(Enum):", baseName));
    for (int i = 0; i < field.enums.size(); i++)
    {
      Enum entry = field.enums.elementAt(i);
      writeln(1, format("%s = %s", entry.name, entry.value));
    }
    writeln(1, "def __str__(self):");
    writeln(2, "return str(self.value)");
    writeln();
}
  static void generateEnumsAsDict(String baseName, Field field)
  {
    if (field.enums.size() > 0)
    {
      writeln(baseName + " = {}");
      for (int j = 0; j < field.enums.size(); j++)
      {
        Enum entry = field.enums.elementAt(j);
        writeln(baseName + "['" + entry.name + "'] = " + entry.value);
      }
      for (int j = 0; j < field.enums.size(); j++)
      {
        Enum entry = field.enums.elementAt(j);
        writeln(baseName + "[" + entry.value + "] = '" + entry.name + "'");
      }
      writeln();
    }
  }
  private static void checkPythonSingle(Table table, Proc proc, String current, boolean hasInputs)
  {
    if (proc.hasReturning && proc.isInsert == true)
    {
      for (int p=0; p<table.fields.size(); p++)
      {
        Field field = table.fields.elementAt(p);
        if (proc.isInsert && (field.type == Field.SEQUENCE || field.type == Field.BIGSEQUENCE))
        {
          writeln(2, "if self._ret.usesPlSql == true:");
          writeln(3, "self." + field.name + " = cursor.var('" + field.name + "')");
          writeln(3, "return self");
          break;
        }
      }
    }
    generatePythonSingle(table, proc, current, hasInputs);
  }
  private static void generatePythonSingle(Table table, Proc proc, String current, boolean hasInputs)
  {
    writeln(2, "record = " + current + "()");
    if (hasInputs)
      writeln(2, "self._copy_input(record)");
    writeln(2, "result = cursor.fetchone()");
    writeln(2, "if result == None:");
    writeln(3, "return None");
    writeln(2, "record._get_output(result)");
    writeln(2, "return record");
  }
  private static void generatePythonMultiple(Table table, Proc proc, String current, boolean hasInputs)
  {
    writeln(2, "records = []");
    writeln(2, "for row in cursor:");
    writeln(3, "record = " + current + "()");
    if (hasInputs)
      writeln(3, "self._copy_input(record)");
    writeln(3, "record._get_output(row)");
    writeln(3, "records.append(record)");
    writeln(2, "return records");
  }
  private static void generatePythonAction(Table table, Proc proc, boolean hasInputs)
  {
  }
  static void generateString(Proc proc, String name, Vector strings)
  {
    String added = "";
    writeln(2, name+" = '''\\");
    for (int i = 0; i < strings.size(); i++)
    {
      String string = (String)strings.elementAt(i);
      if (string.charAt(0) == '"')
        writeln(string.substring(1, string.length() - 1));
      else
      {
        if (added.length() == 0)
          added = added + " % (";
        else
          added = added + ", ";
        String l = string.trim();
        added = added + "self." + l;
        String quotes = "";
        if (proc.isStrung(l) == true)
          quotes = "'";
        writeln(quotes + "%s" + quotes);
      }
    }
    if (added.length() > 0)
      added = added + ")";
    writeln("'''"+added);
  }
  static boolean isNull(Field field)
  {
    if (field.isNull == false)
      return false;
    switch (field.type)
    {
      case Field.BOOLEAN:
      case Field.FLOAT:
      case Field.DOUBLE:
      case Field.MONEY:
      case Field.BYTE:
      case Field.SHORT:
      case Field.INT:
      case Field.LONG:
      case Field.IDENTITY:
      case Field.SEQUENCE:
      case Field.BIGIDENTITY:
      case Field.BIGSEQUENCE:
      case Field.BLOB:
      case Field.DATE:
      case Field.DATETIME:
      case Field.TIMESTAMP:
      case Field.TIME:
        return true;
    }
    return false;
  }
}
