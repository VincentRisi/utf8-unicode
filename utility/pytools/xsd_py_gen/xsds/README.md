# XSD examples

Here are a small set of xsd's - which most have the strange distinction of being flat xsd. 
i.e They have Simple Type and Complex Type as self contained level 1 types mostly.
I do not think they should be giving away any State secrets.

## pain ISO 20022 version

``` xsd
<?xml version="1.0" encoding="UTF-8"?>
<!--Generated by Standards Editor (build:R1.6.15) on 2019 Feb 14 11:57:59, ISO 20022 version : 2013-->
<xs:schema xmlns="urn:iso:std:iso:20022:tech:xsd:pain.001.001.09" xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="urn:iso:std:iso:20022:tech:xsd:pain.001.001.09">
    <xs:element name="Document" type="Document"/>
    <xs:complexType name="AccountIdentification4Choice">
        <xs:choice>
            <xs:element name="IBAN" type="IBAN2007Identifier"/>
            <xs:element name="Othr" type="GenericAccountIdentification1"/>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="AccountSchemeName1Choice">
        <xs:choice>
            <xs:element name="Cd" type="ExternalAccountIdentification1Code"/>
            <xs:element name="Prtry" type="Max35Text"/>
        </xs:choice>
    </xs:complexType>
    <xs:simpleType name="ActiveOrHistoricCurrencyAndAmount_SimpleType">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="5"/>
            <xs:totalDigits value="18"/>
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActiveOrHistoricCurrencyAndAmount">
        <xs:simpleContent>
            <xs:extension base="ActiveOrHistoricCurrencyAndAmount_SimpleType">
                <xs:attribute name="Ccy" type="ActiveOrHistoricCurrencyCode" use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    ....
```
``` python
import GENDS_UTILITY as xsd_check
from datetime import date, datetime, time
byte = short = int

def ActiveOrHistoricCurrencyAndAmount_SimpleType(value):
    base = 'xs:decimal'
    valid = xsd_check.fractionDigits(base, value, '5')
    if valid == True:
        valid = xsd_check.minInclusive(base, value, '0')
    if valid == True:
        valid = xsd_check.totalDigits(base, value, '18')
    return valid

def ActiveOrHistoricCurrencyCode(value):
    base = 'xs:string'
    valid = xsd_check.pattern(base, value, '[A-Z]{3,3}')
    return valid

class AddressType2CodeEnum:
    ADDR = 'ADDR'
    PBOX = 'PBOX'
    HOME = 'HOME'
    BIZZ = 'BIZZ'
    MLTO = 'MLTO'
    DLVY = 'DLVY'

def AddressType2Code(value):
    base = 'xs:string'
    elist = ['ADDR', 'PBOX', 'HOME', 'BIZZ', 'MLTO', 'DLVY']
    valid = value in elist
    return valid

...

class AccountSchemeName1Choice:
    Cd: str
    Prtry: str
    def __init__(self):
        self.Cd = ''
        self.Prtry = ''

class GenericAccountIdentification1:
    Id: str
    SchmeNm: AccountSchemeName1Choice
    Issr: str
    def __init__(self):
        self.Id = ''
        self.SchmeNm = None
        self.Issr = None

class AccountIdentification4Choice:
    IBAN: str
    Othr: GenericAccountIdentification1
    def __init__(self):
        self.IBAN = ''
        self.Othr = GenericAccountIdentification1()
```
## pacs ISO 20022 version

``` xsd
<?xml version="1.0" encoding="UTF-8"?>
<!--Generated by Standards Editor (build:R1.6.15) on 2019 Feb 14 13:31:41, ISO 20022 version : 2013-->
<xs:schema xmlns="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08" xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08">
    <xs:element name="Document" type="Document"/>
    <xs:complexType name="AccountIdentification4Choice">
        <xs:choice>
            <xs:element name="IBAN" type="IBAN2007Identifier"/>
            <xs:element name="Othr" type="GenericAccountIdentification1"/>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="AccountSchemeName1Choice">
        <xs:choice>
            <xs:element name="Cd" type="ExternalAccountIdentification1Code"/>
            <xs:element name="Prtry" type="Max35Text"/>
        </xs:choice>
    </xs:complexType>
    <xs:simpleType name="ActiveCurrencyAndAmount_SimpleType">
        <xs:restriction base="xs:decimal">
            <xs:fractionDigits value="5"/>
            <xs:totalDigits value="18"/>
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActiveCurrencyAndAmount">
        <xs:simpleContent>
            <xs:extension base="ActiveCurrencyAndAmount_SimpleType">
                <xs:attribute name="Ccy" type="ActiveCurrencyCode" use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    ...
```

``` python
import GENDS_UTILITY as xsd_check
from datetime import date, datetime, time
byte = short = int

def ActiveCurrencyAndAmount_SimpleType(value):
    base = 'xs:decimal'
    valid = xsd_check.fractionDigits(base, value, '5')
    if valid == True:
        valid = xsd_check.minInclusive(base, value, '0')
    if valid == True:
        valid = xsd_check.totalDigits(base, value, '18')
    return valid

def ActiveCurrencyCode(value):
    base = 'xs:string'
    valid = xsd_check.pattern(base, value, '[A-Z]{3,3}')
    return valid

def ActiveOrHistoricCurrencyAndAmount_SimpleType(value):
    base = 'xs:decimal'
    valid = xsd_check.fractionDigits(base, value, '5')
    if valid == True:
        valid = xsd_check.minInclusive(base, value, '0')
    if valid == True:
        valid = xsd_check.totalDigits(base, value, '18')
    return valid

def ActiveOrHistoricCurrencyCode(value):
    base = 'xs:string'
    valid = xsd_check.pattern(base, value, '[A-Z]{3,3}')
    return valid

class AddressType2CodeEnum:
    ADDR = 'ADDR'
    PBOX = 'PBOX'
    HOME = 'HOME'
    BIZZ = 'BIZZ'
    MLTO = 'MLTO'
    DLVY = 'DLVY'

def AddressType2Code(value):
    base = 'xs:string'
    elist = ['ADDR', 'PBOX', 'HOME', 'BIZZ', 'MLTO', 'DLVY']
    valid = value in elist
    return valid

...

class AccountIdentification4Choice:
    IBAN: str
    Othr: GenericAccountIdentification1
    def __init__(self):
        self.IBAN = ''
        self.Othr = GenericAccountIdentification1()

class ActiveCurrencyAndAmount:
    Ccy: (str, 'attrib')
    value: (float, 'pseudo')
    def __init__(self):
        self.Ccy = ''
        self.value = 0.0

class ActiveOrHistoricCurrencyAndAmount:
    Ccy: (str, 'attrib')
    value: (float, 'pseudo')
    def __init__(self):
        self.Ccy = ''
        self.value = 0.0

class GenericIdentification30:
    Id: str
    Issr: str
    SchmeNm: str
    def __init__(self):
        self.Id = ''
        self.Issr = ''
        self.SchmeNm = None
```
## GPS Payment

``` xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:complexType name="CustomPaymentComment">
        <xs:attribute name="CommentType" type="xs:string" />
        <xs:attribute name="Comment" type="xs:string" />
        <xs:attribute name="Field" type="xs:string" />
        <xs:attribute name="User" type="xs:string" />
        <xs:attribute name="TimeStamp" type="xs:dateTime" />
        <xs:attribute name="Id" type="xs:int" />
    </xs:complexType>
    <xs:simpleType name="ErrorSeverity">
        <xs:restriction base="xs:string">
            <xs:enumeration id="Error" value="0" />
            <xs:enumeration id="Warning" value="1" />
            <xs:enumeration id="Info" value="2" />
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="MT191AmountWithRate">
        <xs:sequence>
            <xs:element name="Amount" type="xs:float" maxOccurs="1" minOccurs="1" />
            <xs:element name="Currency" type="xs:string" maxOccurs="1" minOccurs="0" />
            <xs:element name="Id" type="xs:int" maxOccurs="1" minOccurs="1" />
            <xs:element name="Rate" type="xs:float" maxOccurs="1" minOccurs="1" />
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="PaymentAmount">
        <xs:sequence>
            <xs:element name="Amount" type="xs:float" maxOccurs="1" minOccurs="1" />
            <xs:element name="Currency" type="xs:string" maxOccurs="1" minOccurs="0" />
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="PaymentAmountWithRate">
        <xs:sequence>
            <xs:element name="Amount" type="xs:float" maxOccurs="1" minOccurs="1" />
            <xs:element name="Currency" type="xs:string" maxOccurs="1" minOccurs="0" />
            <xs:element name="Rate" type="xs:float" maxOccurs="1" minOccurs="1" />
        </xs:sequence>
    </xs:complexType>
    ...
```

``` python
import GENDS_UTILITY as xsd_check
from datetime import date, datetime, time
byte = short = int

class ErrorSeverityEnum:
    Error = '0'
    Warning = '1'
    Info = '2'

def ErrorSeverity(value):
    base = 'xs:string'
    elist = ['0', '1', '2']
    valid = value in elist
    return valid

class PaymentTypeEnum:
    Unknown = '0'
    ZarOnUs = '1'
    CcyOnUs = '2'
    ZarPayOn = '3'
    CcyPayOn = '4'
    VostroZarOnUs = '5'
    VostroZarPayOn = '6'
    ClsZarPayIn = '7'
    ClsZarPayOut = '8'
    VostroCcyOnUs = '9'
    VostroCcyPayOn = '10'
    ClsCcyPayIn = '11'
    ClsCcyPayOut = '12'
    CcyConversionPayOn = '13'
    OutgoingPayOn = '20'
    OutgoingIntraOnUs = '21'
    OutgoingInterOnUs = '22'
    OutgoingBankToBank = '23'

def PaymentType(value):
    base = 'xs:string'
    elist = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '20', '21', '22', '23']
    valid = value in elist
    return valid

...

class CustomPaymentComment:
    CommentType: (str, 'attrib')
    Comment: (str, 'attrib')
    Field: (str, 'attrib')
    User: (str, 'attrib')
    TimeStamp: (datetime, 'attrib')
    Id: (int, 'attrib')
    def __init__(self):
        self.CommentType = ''
        self.Comment = ''
        self.Field = ''
        self.User = ''
        self.TimeStamp = ''
        self.Id = 0

class MT191AmountWithRate:
    Amount: str
    Currency: str
    Id: str
    Rate: str
    def __init__(self):
        self.Amount = ''
        self.Currency = None
        self.Id = ''
        self.Rate = ''

class PaymentAmount:
    Amount: str
    Currency: str
    def __init__(self):
        self.Amount = ''
        self.Currency = None

class PaymentAmountWithRate:
    Amount: str
    Currency: str
    Rate: str
    def __init__(self):
        self.Amount = ''
        self.Currency = None
        self.Rate = ''

...

class Payment:
    class AdditionalFields:
        PaymentInfoField: [PaymentInfoField] ## PaymentInfoField
        def __init__(self):
            self.PaymentInfoField = []
    class BeneficiaryAccounts:
        PaymentBeneficiaryAccount: [PaymentBeneficiaryAccount] ## PaymentBeneficiaryAccount
        def __init__(self):
            self.PaymentBeneficiaryAccount = []
    Id: (str, 'attrib')
    SessionNo: (int, 'attrib')
    SequenceNo: (int, 'attrib')
    PaymentReference: str
    RelatedReference: str
    SendersReference: str
    ReceiverReference: str
    Profile: PaymentProfile
    BOPRecs: [PaymentBOP] ## PaymentBOP
    FINSURVRecs: [PaymentFINSURV] ## PaymentFINSURV
    SaffyNo: str
    ProductCode: str
    InputDate: str
    OutputDate: str
    ReceivedDate: str
    OriginalBrnNo: str
    ProcessingBrnNo: str
    RoutedFromBrnNo: str
    FinancialBrnNo: str
    Channel: str
    ChannelType: str
    AdditionalFields: AdditionalFields
    PaymentType: str
    SwiftType: str
    SwiftMessage: str
    Priority: str
    AssignTo: str
    ValueDate: str
    OriginalValueDate: str
    ProcessedDate: str
    TmStamp: str
    Principle: PaymentAmount
    Instructed: PaymentAmountWithRate
    OriginalInstructed: PaymentAmountWithRate
    ZAREq: PaymentAmount
    Settlement: PaymentAmount
    TotalCharge: PaymentAmount
    ChargeType: str
    OutChargeType: str
    SendersCharges: [PaymentAmount] ## PaymentAmount
    ReceiversCharges: [PaymentAmount] ## PaymentAmount
    IFI: PaymentIFI
    TransactionDate: PaymentDate
    SendersBank: PaymentBank
    RecipientBank: PaymentBank
    OrderingCustomer: PaymentBank
    OrderingInstitution: PaymentBank
    SendersCorrespondent: PaymentBank
    ReceiversCorrespondent: PaymentBank
    ThirdReimbursementBank: PaymentBank
    IntermediaryBank: PaymentBank
    FundsWith: PaymentBank
    Beneficiary: PaymentBank
    AccountWith: PaymentBank
    SenderToReceiverInfo: str
    OrderingCustomerB: PaymentBank
    OrderingInstitutionB: PaymentBank
    IntermediaryBankB: PaymentBank
    AccountWithB: PaymentBank
    BeneficiaryB: PaymentBank
    SenderToReceiverInfoB: str
    DebitBank: PaymentBank
    CreditBank: PaymentBank
    BeneficiaryDetails: PaymentBeneficiary
    BeneficiaryAccounts: BeneficiaryAccounts
    BeneficiaryCharge: PaymentBeneficiaryCharge
    PaymentFEC: [PaymentFECClass] ## PaymentFECClass
    OutSendersCorrespondent: PaymentBank
    OutReceiversCorrespondent: PaymentBank
    STP: str
    PaymentOutflags: Paymentflags
    Indicators: PaymentIndicators
    MT103: PaymentBank
    MT202COV: PaymentBank
    MT202BANK: PaymentBank
    MT191: MT191AmountWithRate
    MT199: PaymentBank
    NedbankCorrespondent: PaymentBank
    MCPEResponse: str
    MCPEStatus: str
    CLSData: PaymentCLS
    CoverData: PaymentCoverClass
    ReturnDetails: PaymentReturn
    UETR: str
    PaymentUserNotesITT: [PaymentUserNotes] ## PaymentUserNotes
    Errors: [PaymentError] ## PaymentError
    Comments: [PaymentComment] ## PaymentComment
    CustomComments: [CustomPaymentComment] ## CustomPaymentComment
    Authorisations: [PaymentAuthorisation] ## PaymentAuthorisation
    def __init__(self):
        self.Id = None
        self.SessionNo = None
        self.SequenceNo = None
        self.PaymentReference = ''
        self.RelatedReference = ''
        self.SendersReference = ''
        self.ReceiverReference = None
        self.Profile = PaymentProfile()
        self.BOPRecs = []
        self.FINSURVRecs = []
        self.SaffyNo = ''
        self.ProductCode = None
        self.InputDate = ''
        self.OutputDate = ''
        self.ReceivedDate = ''
        self.OriginalBrnNo = ''
        self.ProcessingBrnNo = ''
        self.RoutedFromBrnNo = ''
        self.FinancialBrnNo = None
        self.Channel = ''
        self.ChannelType = ''
        self.AdditionalFields = Payment.AdditionalFields()
        self.PaymentType = ''
        self.SwiftType = ''
        self.SwiftMessage = ''
        self.Priority = ''
        self.AssignTo = ''
        self.ValueDate = ''
        self.OriginalValueDate = ''
        self.ProcessedDate = ''
        self.TmStamp = ''
        self.Principle = PaymentAmount()
        self.Instructed = PaymentAmountWithRate()
        self.OriginalInstructed = PaymentAmountWithRate()
```

## Annotation and code completion
The flat xsd's have the advantage of having Python code generated with a flat class structure with annotations allowing for reasonable code completion capabilities.

``` python
'''GENDS_UTILITY
    We supply the following main routines here

    - load_message(cls, message, logfile=sys.stdout)
        payment = Payment()
        load_message(payment, message)

    - as_xml(cls)
        message = as_xml(payment)

    - validate(func, value, default=None)
        valid = GENDS_UTILITY.validate
        OrigSystem = valid(OrigSystemType, 'ABCDEF')

    - amp_fix(value) 
        will escape lt Gt Quote Apostrophe and Ampersand characters
'''
from datetime import date, datetime, time
try:
    import xml.etree.cElementTree as etree
except:
    import xml.etree.ElementTree as etree
from xml.dom import minidom
from io import BytesIO, StringIO
import re, sys

byte = short = int

def validate(func, value, default=None):
    try:
        rc = func(value)
        if rc == True: 
            return value
        else:
            return default
    except Exception as ex:
        print (f'{ex.message}')
        return default
```